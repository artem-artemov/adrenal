library(monocle3)
library(igraph)
library(gplots)

library(pheatmap)
library(viridis)
library(ggplot2)

library(Seurat)

# creates monocle objects from seurat object SR
seurat2monocle = function(SR, fix_partitions=F){
    gene_annotation = SR@assays$RNA@meta.features
    gene_annotation$gene_short_name = rownames(gene_annotation)

    cds <- new_cell_data_set(SR@assays$RNA@counts,
                             cell_metadata = SR@meta.data,
                             gene_metadata = gene_annotation)
    cds <- preprocess_cds(cds, num_dim = 100)
    
    UMAP = SR@reductions$umap@cell.embeddings
    cds@reducedDims$UMAP = UMAP

    cds <- cluster_cells(cds)
    
    colData(cds)$seurat_cluster = factor(SR@meta.data$seurat_cluster)
    
    if(fix_partitions){
        cds@clusters$UMAP$partitions = factor(rep(1, length(cds@clusters$UMAP$partitions)))
    }
    
    cds <- learn_graph(cds, use_partition = T)


    plot_cells(cds,
               color_cells_by = "seurat_cluster",
               label_groups_by_cluster=FALSE,
               label_leaves=FALSE,
               label_branch_points=T,
              cell_size = 0.5,
              label_cell_groups=F)+NoLegend()


    cds
}

# saves heatmap generated by pheatmap to pdf
save_pheatmap_pdf <- function(x, filename, width=7, height=7) {
   stopifnot(!missing(x))
   stopifnot(!missing(filename))
   pdf(filename, width=width, height=height)
   grid::grid.newpage()
   grid::grid.draw(x$gtable)
   dev.off()
}

#cds_sel@clusters$UMAP$partitions[cds_sel@clusters$UMAP$partitions == "2"] <- "1"
#levels(cds_sel@clusters$UMAP$partitions)=1
#cds_sel@clusters$UMAP$partitions = factor(rep(cds_sel@clusters$UMAP$partitions, length(cds_sel@clusters$UMAP$partitions)))



# For a transition between graph nodes 'from' and 'to' in a principal graph, 
# finds differential genes and plots a heatmap of gene expression along pseudotime
#
# @param cds monocle3 object with principal_graph calculated
# @param from branch node of the principal_graph where the transition starts
# @param to branch node of the principal_graph where the transition ends
# @param pr_deg_ids genes of interest to be plotted on the heatmap 
# (NULL) to discover genes automatically
# @param f_heatmap character, filename for the generated heatmap
# @param lmar (optional) ignore the first lmar cells in the heatmap (ordered according to pseudotime)
# @param return_matrix returns matrix of smoothed gene expression instead of plotting the heatmap
# @param qv_cutoff q_value cutoff for monocle3 graph_test
# @param min_var minimal variance for monocle3 graph_test
#
analyze_bridge=function(cds, from, to, pr_deg_ids=NULL, f_heatmap = 'figures/tmp.heatmap.pdf', lmar=1, return_matrix=F,
                       qv_cutoff=10^-50, min_var=10){
    # locate 'from' and 'to' nodes in the principal tree
    branchnodes = monocle3:::branch_nodes(cds)
    y0 = names(branchnodes)[from]
    y1 =names(branchnodes)[to]

    # find a path between 'from' and 'to' nodes
    path = subgraph(cds@principal_graph$UMAP, all_simple_paths(cds@principal_graph$UMAP, y0, y1)[[1]])
    plot(path)
    
    # for each cell, find the closest vertex of the principal tree
    closest_vertex <- paste0('Y_', cds@principal_graph_aux$UMAP$pr_graph_cell_proj_closest_vertex)

    # subset only cells, for which the closest path belongs to the path path between 'from' and 'to' nodes
    cds_sel = cds[,closest_vertex %in% names(V(path))]

    # order cells according to pseudotime
    cds_sel_pt = order_cells(cds_sel, reduction_method = 'UMAP', root_pr_nodes = y0)
    
    # plot trajectory, color cells by pseudotime
    print(gsub('heatmap.pdf', 'trajectory.pdf', f_heatmap))
    p_traject = plot_cells(cds_sel_pt,
               color_cells_by = "pseudotime",
               label_cell_groups=FALSE,
               label_leaves=FALSE,
               label_branch_points=FALSE,
               graph_label_size=1.5,
               label_roots = F,
               trajectory_graph_segment_size = 0.2,
               cell_size = 1)+ theme(legend.position = "none")
    print(p_traject)
    ggsave(gsub('heatmap.pdf', 'trajectory.pdf', f_heatmap), width=5, height=5)

    # if no genes of interest are specified, perform a test to find genes with a pattern along the trajectory
    clusterrows = is.null(pr_deg_ids)
    if(is.null(pr_deg_ids)){
        pr_test_res <- graph_test(cds_sel_pt, neighbor_graph="principal_graph", cores=1)
        pr_deg_ids <- row.names(subset(pr_test_res, q_value < qvcutoff & vst.variance>min_var )) #vst.variance.expected>1
        pr_deg_ids = pr_deg_ids[!startsWith(pr_deg_ids, "Hb")]
        length(pr_deg_ids)
        print(pr_deg_ids)
    }
    
    cds_subset = cds_sel_pt[pr_deg_ids,]
    colData(cds_subset)$pseudotime = pseudotime(cds_subset)

    # smooth gene expression along pseudotime
    trend_formula='~ splines::ns(pseudotime, df=3)'
    new_data <- data.frame(pseudotime = colData(cds_subset)$pseudotime)

    model_tbl = fit_models(cds_subset, model_formula_str = trend_formula)

    model_expectation <- model_predictions(model_tbl,
                                             new_data = colData(cds_subset))
    
    
    heatmap_matrix = na.omit(log10(as.matrix(model_expectation))[,order(colData(cds_subset)$pseudotime)])
    
    heatmap_matrix = heatmap_matrix[,lmar:ncol(heatmap_matrix)]
    
    if(return_matrix){
        return(cds_sel_pt[,order(colData(cds_subset)$pseudotime)]@assays$data[[1]])
    }

    #plot heatmap
    ph <- pheatmap(heatmap_matrix, 
                     useRaster = T,
                     cluster_cols=FALSE, 
                     cluster_rows=clusterrows, 
                     show_rownames=T, 
                     show_colnames=F, 
                     #clustering_distance_rows=row_dist,
                     #clustering_method = ,
                     #cutree_rows=num_clusters,
                     silent=F,
                     filename=NA,
                     #breaks=bks,
                     border_color = NA,
                     #color=hmcols
                   scale='row'#,
                   #color=viridis(100)
                  ) #+ theme(legend.position = "none")

    save_pheatmap_pdf(ph, f_heatmap, 5, 5)
    
    ph
    
}

# For a transition between graph nodes 'from' and 'to' in a principal graph, 
# finds pseudotime for each cell, splits the cells into three populations according to the pseutorime:
# A - initial population, B - bridge, C - final population.
# For cells in B, finds genes for which gene expression can not be explained as a linear combination
# of gene expression profiles of A and B
#
# @param cds monocle3 object with principal_graph calculated
# @param from branch node of the principal_graph where the transition starts
# @param to branch node of the principal_graph where the transition ends
# @param pst_breaks a numeric vector of size 2, pseudotime values separating populations A, B and C
# @param pr_deg_ids genes of interest to be plotted on the heatmap 
# (NULL) to discover genes automatically
# @param prefix character, filename prefix for the generated plots
#
bridge_genes=function(cds, from, to, pst_breaks=c(0.4,0.7), pr_deg_ids=NULL, prefix='figures/tmp'){
    # locate 'from' and 'to' nodes in the principal tree
    branchnodes = monocle3:::branch_nodes(cds)
    y0 = names(branchnodes)[from]
    y1 =names(branchnodes)[to]
    
    # find a path between 'from' and 'to' nodes
    path = subgraph(cds@principal_graph$UMAP, all_simple_paths(cds@principal_graph$UMAP, y0, y1)[[1]])
    
    # for each cell, find the closest vertex of the principal tree
    closest_vertex <- paste0('Y_', cds@principal_graph_aux$UMAP$pr_graph_cell_proj_closest_vertex)

    # subset only cells, for which the closest path belongs to the path path between 'from' and 'to' nodes
    cds_sel = cds[,closest_vertex %in% names(V(path))]
    cds_sel

    # order cells according to pseudotime
    cds_sel_pt = order_cells(cds_sel, reduction_method = 'UMAP', root_pr_nodes = y0)
    
    # plot trajectory, color cells by pseudotime
    p_traject = plot_cells(cds_sel_pt,
               color_cells_by = "pseudotime",
               label_cell_groups=FALSE,
               label_leaves=FALSE,
               label_branch_points=FALSE,
               graph_label_size=1.5,
               label_roots = F,
               trajectory_graph_segment_size = 0.2,
               cell_size = 1)#+ theme(legend.position = "none")
    print(p_traject)
    print(p_traject+ theme(legend.position = "none"))
    ggsave(paste0(prefix, '.trajectory.pdf'), plot = p_traject + theme(legend.position = "none"),
           width=5, height=5)
    
    #split cells into 3 groups (A, bridge B, C) according to pseudotime
    colData(cds_sel_pt)$pseudotime = pseudotime(cds_sel_pt)
    colData(cds_sel_pt)$group = ifelse(colData(cds_sel_pt)$pseudotime<pst_breaks[1], 1,
                                      ifelse(colData(cds_sel_pt)$pseudotime>pst_breaks[2], 3, 2))
    
    # plot trajectory, color cells by group
    p_traject_group = plot_cells(cds_sel_pt,
               color_cells_by = "group",
               label_cell_groups=FALSE,
               label_leaves=FALSE,
               label_branch_points=FALSE,
               graph_label_size=1.5,
               label_roots = F,
               trajectory_graph_segment_size = 0.2,
               cell_size = 1)+ theme(legend.position = "none")
    print(p_traject_group)
    ggsave(paste0(prefix, '.groups.pdf'), plot = p_traject_group,
           width=5, height=5)

    
    # for each gene, find if expression in bridge B population can not be explained 
    # as a linear combination of gene expression profiles in A (initial) and B (final) populations
    M = cds_sel_pt[,order(colData(cds_sel_pt)$pseudotime)]@assays$data[[1]]
    cn = colnames(M)
    rss = lin.dev(cn[1:round(length(cn)/3)], 
                  cn[(1+round(2*length(cn)/3)):length(cn)], 
                  cn[(1+round(length(cn)/3)):round(2*length(cn)/3)], 
                  t(M))

    library(ggplot2)
    library(ggrepel)

    # plot gene expression residuals from the linear model for the top genes
    n <- 50;
    df <- data.frame(gene=names(rss)[1:n],r=rss[1:n])
    pl = ggplot(df,aes(x=nrow(df)-rank(r),y=r,label=gene))+geom_point()+geom_text_repel()+xlab("gene rank")+ylab('normalized residual')+theme_bw()
    print(pl)
    ggsave(paste0(prefix, '.genes.pdf'), plot = pl,
           width=5, height=5)

    # smooth expression of the top genes according to the pseudotime
    pr_deg_ids = as.character(df$gene)
    cds_subset = cds_sel_pt[pr_deg_ids,]
    
    trend_formula='~ splines::ns(pseudotime, df=3)'
    new_data <- data.frame(pseudotime = colData(cds_subset)$pseudotime)

    model_tbl = fit_models(cds_subset, model_formula_str = trend_formula)

    model_expectation <- model_predictions(model_tbl,
                                             new_data = colData(cds_subset))
    
    
    heatmap_matrix = na.omit(log10(as.matrix(model_expectation))[,order(colData(cds_subset)$pseudotime)])
    
    heatmap_matrix = heatmap_matrix
    
    #plot hearmap of the top genes alont the pseudotime
    ph <- pheatmap(heatmap_matrix, 
                     useRaster = T,
                     cluster_cols=FALSE, 
                     cluster_rows=T, 
                     show_rownames=T, 
                     show_colnames=F, 
                     #clustering_distance_rows=row_dist,
                     #clustering_method = ,
                     #cutree_rows=num_clusters,
                     silent=F,
                     filename=NA,
                     #breaks=bks,
                     border_color = NA,
                     #color=hmcols
                   scale='row'#,
                   #color=viridis(100)
                  ) #+ theme(legend.position = "none")

    save_pheatmap_pdf(ph, paste0(prefix, '.heatmap.5x8.pdf'), 5, 8)

    return(list(p_traject, p_traject+ theme(legend.position = "none"),
                p_traject_group, 
                pl,
                ph))
    
}



library(conos)
# returns normalized mean residuals per gene within the cel3 population, relative to a simple linear model mixing cel1 and cel2 populations
# @param cel1 - vector of cell names for the initial population (A)
# @param cel2 - vector of cell names for the final population (C)
# @param cel3 - vector of cell names for the bridge population (B)
# @param mat - matrix of molecule counts (raw counts - not normalized)
#
lin.dev <- function(cel1,cel2,cel3,mat) {
    mat <- mat[rownames(mat) %in% c(cel1,cel2,cel3),,drop=F]

    cf = rep(0, nrow(mat))
    cf[rownames(mat) %in% cel1] = 1
    cf[rownames(mat) %in% cel2] = 2
    cf[rownames(mat) %in% cel3] = 3

    # calculate average gene expression profiles for genes in the initial (A) and final (C) populations
    cm1 = colSums(mat[rownames(mat) %in% cel1,])
    cm2 = colSums(mat[rownames(mat) %in% cel2,])
    
    # fit linear model on the bridge cells with no intercept term
    x <- as.matrix(t(mat[cel3,]))
    y <- lm(x~cm1+cm2-1)

    # calculate pearson residual using sd from all three populations (instead of a standard studentized resiudal)
    rs <- residuals(y,'response')
    rss <- rowMeans(rs)
    rss <- rss/apply(mat,2,sd) # all three populations
    rss <- rss[is.finite(rss)]
    rss <- rss[order(rss, decreasing=T)]
    rss
}
